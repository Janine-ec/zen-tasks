{
  "name": "05 - Task Agent (Unified)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "task-agent",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "task-agent-webhook",
      "name": "Task Agent Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "tasks",
        "returnAll": true,
        "filterType": "string",
        "filterString": "=user_id=eq.{{ $json.body.user_id }}&status=in.(pending,in_progress)&order=urgency.desc,importance.desc,created_at.asc"
      },
      "id": "fetch-active-tasks",
      "name": "Fetch Active Tasks",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [440, 300],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const webhookData = $('Task Agent Webhook').first().json.body;\nconst tasks = $input.all().map(item => ({\n  id: item.json.id,\n  title: item.json.title,\n  description: item.json.description,\n  urgency: item.json.urgency,\n  importance: item.json.importance,\n  estimated_minutes: item.json.estimated_minutes,\n  due_date: item.json.due_date,\n  location: item.json.location,\n  status: item.json.status,\n  tags: item.json.tags,\n  energy_level: item.json.energy_level,\n  snoozed_until: item.json.snoozed_until\n}));\n\nreturn [{ json: { ...webhookData, active_tasks: tasks } }];"
      },
      "id": "prepare-ai-context",
      "name": "Prepare AI Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin={{ new Date().toISOString() }}&timeMax={{ new Date(Date.now() + 60*24*60*60*1000).toISOString() }}&singleEvents=true&orderBy=startTime&maxResults=50",
        "options": {}
      },
      "id": "fetch-calendar",
      "name": "Fetch Calendar Events",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [880, 300],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "GOOGLE_CALENDAR_CREDENTIAL_ID",
          "name": "Google Calendar"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const context = $('Prepare AI Context').first().json;\nconst calResponse = $input.first().json;\n\n// Extract calendar events (gracefully handle failures)\nconst calendarEvents = (calResponse.items || []).map(e => ({\n  summary: e.summary || '(no title)',\n  start: e.start?.dateTime || e.start?.date || null,\n  end: e.end?.dateTime || e.end?.date || null,\n  location: e.location || null,\n  allDay: !!e.start?.date\n}));\n\n// Build time context\nconst now = new Date();\nconst hours = now.getHours();\nconst dayOfWeek = now.toLocaleDateString('en-US', { weekday: 'long' });\nconst isWeekend = [0, 6].includes(now.getDay());\n\nlet timeOfDay;\nif (hours < 9) timeOfDay = 'early morning';\nelse if (hours < 12) timeOfDay = 'morning';\nelse if (hours < 14) timeOfDay = 'lunchtime';\nelse if (hours < 17) timeOfDay = 'afternoon';\nelse if (hours < 20) timeOfDay = 'evening';\nelse timeOfDay = 'late night';\n\nreturn [{\n  json: {\n    ...context,\n    calendar_events: calendarEvents,\n    current_time: now.toISOString(),\n    time_of_day: timeOfDay,\n    day_of_week: dayOfWeek,\n    is_weekend: isWeekend,\n    is_business_hours: hours >= 8 && hours < 18 && !isWeekend\n  }\n}];"
      },
      "id": "enrich-context",
      "name": "Enrich with Calendar",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are Zen Tasks, a friendly task management assistant. You help the user manage their to-do list through natural conversation.\n\nThe user opened the chat in \"{{ $json.mode }}\" mode, which hints at their primary intent:\n- \"add\" mode: They probably want to create new tasks\n- \"clear\" mode: They probably want to complete, delete, snooze, or get suggestions about existing tasks\nBut they may express any intent in either mode — always respond to what they actually say.\n\nConversation so far:\n{{ JSON.stringify($json.history || []) }}\n\nUser's latest message:\n\"{{ $json.message }}\"\n\nTheir current active tasks:\n{{ JSON.stringify($json.active_tasks) }}\n\nUpcoming calendar events (next 60 days):\n{{ JSON.stringify($json.calendar_events) }}\n\nCurrent time context:\n- Now: {{ $json.current_time }}\n- Time of day: {{ $json.time_of_day }}\n- Day: {{ $json.day_of_week }}\n- Weekend: {{ $json.is_weekend }}\n- Business hours: {{ $json.is_business_hours }}\n\nToday's date: {{ new Date().toISOString().split('T')[0] }}\n\n---\n\nYou must respond with ONLY valid JSON (no markdown fences, no extra text).\n\nChoose exactly ONE action per response from the following:\n\n### ACTION: create\nUse when the user wants to add new task(s). The user may mention multiple tasks at once — capture all of them.\n\nCALENDAR AWARENESS: If the user references an event or date relative to a calendar event (e.g. \"after Sophie's wedding\", \"before my dentist appointment\"), look it up in the calendar_events list above.\n- If you find a matching event, use its date to set the due_date\n- If you DON'T find a match, use the \"clarify\" action to ask: \"I couldn't find [event] on your calendar. When is it?\"\n- If the user gives a vague timeframe like \"next week\" or \"soon\", pick a reasonable date\n\nDUPLICATE DETECTION: Before creating, check if any active task has a very similar title or clearly refers to the same thing. If so, ask the user first:\n  {\"action\": \"clarify\", \"reply\": \"You already have a similar task: '<existing title>'. Should I update that one or create a new task?\"}\n\nCONFIDENCE CHECK: After determining urgency, importance, and duration, assess your confidence:\n- If the user gave clear signals (explicit deadline, said \"urgent\", \"quick task\", \"important\"), go ahead and create\n- If the task is ambiguous (e.g. just \"buy groceries\" with no context), make your best guess BUT include a brief note in your reply like: \"I've set this as medium urgency — let me know if it's more pressing!\"\n- If you genuinely can't tell (e.g. could be 5 minutes or 5 hours), use \"clarify\" to ask ONE focused question about the most uncertain field, not multiple questions at once\n\nIf creating:\n{\n  \"action\": \"create\",\n  \"reply\": \"<friendly confirmation that mentions key assumptions you made>\",\n  \"tasks\": [\n    {\n      \"title\": \"<clear, concise title>\",\n      \"description\": \"<extra detail or null>\",\n      \"urgency\": <1-5>,\n      \"importance\": <1-5>,\n      \"estimated_minutes\": <number or null>,\n      \"due_date\": \"<ISO 8601 or null>\",\n      \"location\": \"<specific place or null>\",\n      \"tags\": [\"<tag>\"],\n      \"energy_level\": \"<low|medium|high>\",\n      \"can_be_split\": <true|false>,\n      \"recurrence\": \"<weekly|daily|etc or null>\",\n      \"depends_on_title\": \"<title of dependency task or null>\"\n    }\n  ]\n}\n\n### ACTION: complete\nUse when the user says they finished/completed a task.\n{\"action\": \"complete\", \"task_id\": \"<uuid>\", \"reply\": \"<congratulations message>\"}\n\n### ACTION: start\nUse when the user says they're ABOUT TO do a task (not done yet).\n{\"action\": \"start\", \"task_id\": \"<uuid>\", \"follow_up_minutes\": <estimated_minutes or 30>, \"reply\": \"<encouraging message, mention you'll check back>\"}\n\n### ACTION: delete\nUse when the user wants to remove a task they no longer need.\n{\"action\": \"delete\", \"task_id\": \"<uuid>\", \"reply\": \"<confirmation message>\"}\n\n### ACTION: snooze\nUse when the user wants to temporarily hide a task.\n{\"action\": \"snooze\", \"task_id\": \"<uuid>\", \"snoozed_until\": \"<ISO 8601>\", \"reply\": \"<confirmation with when it will reappear>\"}\n\n### ACTION: suggest\nUse when the user asks \"what should I do now?\" or wants a recommendation.\nPick the best task considering:\n- Eisenhower matrix: urgent+important first, then important, then urgent\n- Due dates approaching\n- TIME OF DAY APPROPRIATENESS:\n  - Late night (8pm+): Don't suggest phone calls, errands, or anything requiring other people. Prefer low-energy tasks like planning, reading, or organising.\n  - Early morning: Good for focused work, exercise\n  - Business hours: Good for calls, emails, appointments, errands\n  - Weekends: Prefer personal tasks over work tasks unless work tasks are urgent\n- Energy level match: suggest low-energy tasks in the evening, high-energy in the morning\n- Estimated duration: suggest quick tasks if time is limited\n{\"action\": \"suggest\", \"task_id\": \"<uuid>\", \"reply\": \"<friendly suggestion explaining why this task fits right now>\"}\n\n### ACTION: clarify\nUse when you need more information, the user's intent is unclear, you can't find a referenced calendar event, or you want to confirm something.\n{\"action\": \"clarify\", \"reply\": \"<your question>\"}\n\n---\n\nRULES:\n1. Match existing tasks by fuzzy title matching — the user won't say the exact title.\n2. If multiple tasks could match, use the \"clarify\" action to ask which one.\n3. For \"create\", make reasonable assumptions but BE TRANSPARENT about them in your reply.\n4. If the user mentions both adding AND managing tasks in one message, handle the most prominent intent first, then mention the other.\n5. Be concise, friendly, and warm.\n6. Always use the task's actual UUID from active_tasks when referencing existing tasks — never make up IDs.\n7. For the \"create\" action, you may include multiple tasks in the array if the user mentions several.\n8. For all other actions, handle exactly one task per response.\n9. NEVER suggest tasks that are inappropriate for the current time of day or day of week.\n10. When creating tasks, if the user references a calendar event for timing, mention which event you matched it to in your reply.",
        "options": {}
      },
      "id": "task-agent-ai",
      "name": "Task Agent AI",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1320, 300]
    },
    {
      "parameters": {
        "jsCode": "const rawMessage = $('Task Agent Webhook').first().json.body.message;\nconst userId = $('Task Agent Webhook').first().json.body.user_id;\nconst history = $('Task Agent Webhook').first().json.body.history || [];\n\nlet parsed;\ntry {\n  let text = $input.first().json.output || $input.first().json.text || '';\n  text = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  parsed = JSON.parse(text);\n} catch (e) {\n  const fallbackText = $input.first().json.output || $input.first().json.text\n    || 'Could you tell me more about that?';\n  return [{ json: {\n    action: 'clarify',\n    replies: [fallbackText],\n    done: false\n  }}];\n}\n\nconst action = parsed.action;\n\nif (action === 'create') {\n  const tasks = (parsed.tasks || [parsed]).map(t => ({\n    user_id: userId,\n    raw_input: rawMessage,\n    title: t.title || rawMessage,\n    description: t.description || null,\n    urgency: Math.max(1, Math.min(5, parseInt(t.urgency) || 3)),\n    importance: Math.max(1, Math.min(5, parseInt(t.importance) || 3)),\n    estimated_minutes: t.estimated_minutes ? parseInt(t.estimated_minutes) : null,\n    due_date: t.due_date || null,\n    location: t.location || null,\n    tags: Array.isArray(t.tags) ? t.tags : [],\n    energy_level: ['low','medium','high'].includes(t.energy_level) ? t.energy_level : 'medium',\n    can_be_split: !!t.can_be_split,\n    recurrence: t.recurrence || null,\n    ai_conversation: history,\n    status: 'pending'\n  }));\n  const replies = parsed.replies\n    || (parsed.reply ? [parsed.reply] : tasks.map(t => 'Added: ' + t.title));\n  return [{ json: { action: 'create', replies, done: true, tasks } }];\n}\n\nif (['complete', 'start', 'delete', 'snooze'].includes(action)) {\n  return [{ json: {\n    action,\n    task_id: parsed.task_id || null,\n    follow_up_minutes: parsed.follow_up_minutes || null,\n    snoozed_until: parsed.snoozed_until || null,\n    replies: parsed.replies || [parsed.reply],\n    done: true\n  }}];\n}\n\nif (action === 'suggest' || action === 'clarify') {\n  return [{ json: {\n    action,\n    task_id: parsed.task_id || null,\n    replies: parsed.replies || [parsed.reply],\n    done: false\n  }}];\n}\n\n// Unknown action fallback\nreturn [{ json: {\n  action: 'clarify',\n  replies: [parsed.reply || \"I'm not sure what you mean. Could you rephrase?\"],\n  done: false\n}}];"
      },
      "id": "parse-agent-response",
      "name": "Parse Agent Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "create",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "complete",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "start",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "delete",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "snooze",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "clarify",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            },
            {
              "conditions": {
                "options": { "caseSensitive": true, "leftValue": "" },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "suggest",
                    "operator": { "type": "string", "operation": "equals" }
                  }
                ]
              }
            }
          ]
        },
        "options": {
          "fallbackOutput": "none"
        }
      },
      "id": "route-action",
      "name": "Route Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [1760, 300]
    },
    {
      "parameters": {
        "jsCode": "return ($input.first().json.tasks || []).map(t => ({ json: t }));"
      },
      "id": "split-new-tasks",
      "name": "Split New Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2020, 60]
    },
    {
      "parameters": {
        "operation": "create",
        "tableId": "tasks",
        "fieldsUi": {
          "fieldValues": [
            { "fieldId": "user_id", "fieldValue": "={{ $json.user_id }}" },
            { "fieldId": "raw_input", "fieldValue": "={{ $json.raw_input }}" },
            { "fieldId": "title", "fieldValue": "={{ $json.title }}" },
            { "fieldId": "description", "fieldValue": "={{ $json.description }}" },
            { "fieldId": "urgency", "fieldValue": "={{ $json.urgency }}" },
            { "fieldId": "importance", "fieldValue": "={{ $json.importance }}" },
            { "fieldId": "estimated_minutes", "fieldValue": "={{ $json.estimated_minutes }}" },
            { "fieldId": "due_date", "fieldValue": "={{ $json.due_date }}" },
            { "fieldId": "location", "fieldValue": "={{ $json.location }}" },
            { "fieldId": "tags", "fieldValue": "={{ $json.tags }}" },
            { "fieldId": "energy_level", "fieldValue": "={{ $json.energy_level }}" },
            { "fieldId": "can_be_split", "fieldValue": "={{ $json.can_be_split }}" },
            { "fieldId": "recurrence", "fieldValue": "={{ $json.recurrence }}" },
            { "fieldId": "ai_conversation", "fieldValue": "={{ $json.ai_conversation }}" },
            { "fieldId": "status", "fieldValue": "={{ $json.status }}" }
          ]
        },
        "options": {}
      },
      "id": "insert-task",
      "name": "Insert Task",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2240, 60],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "tasks",
        "filters": {
          "conditions": [
            { "keyName": "id", "condition": "eq", "keyValue": "={{ $('Parse Agent Response').item.json.task_id }}" }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            { "fieldId": "status", "fieldValue": "completed" }
          ]
        }
      },
      "id": "mark-complete",
      "name": "Mark Complete",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2020, 200],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "tasks",
        "filters": {
          "conditions": [
            { "keyName": "id", "condition": "eq", "keyValue": "={{ $('Parse Agent Response').item.json.task_id }}" }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            { "fieldId": "status", "fieldValue": "in_progress" },
            { "fieldId": "follow_up_at", "fieldValue": "={{ new Date(Date.now() + ($('Parse Agent Response').item.json.follow_up_minutes || 30) * 60000).toISOString() }}" }
          ]
        }
      },
      "id": "mark-in-progress",
      "name": "Mark In Progress",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2020, 340],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "tasks",
        "filters": {
          "conditions": [
            { "keyName": "id", "condition": "eq", "keyValue": "={{ $('Parse Agent Response').item.json.task_id }}" }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            { "fieldId": "status", "fieldValue": "deleted" }
          ]
        }
      },
      "id": "soft-delete",
      "name": "Soft Delete",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2020, 480],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "tasks",
        "filters": {
          "conditions": [
            { "keyName": "id", "condition": "eq", "keyValue": "={{ $('Parse Agent Response').item.json.task_id }}" }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            { "fieldId": "snoozed_until", "fieldValue": "={{ $('Parse Agent Response').item.json.snoozed_until }}" }
          ]
        }
      },
      "id": "snooze-task",
      "name": "Snooze Task",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [2020, 620],
      "credentials": {
        "supabaseApi": {
          "id": "SUPABASE_CREDENTIAL_ID",
          "name": "Supabase"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ replies: $('Parse Agent Response').first().json.replies, done: true }) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "respond-done",
      "name": "Respond Action Done",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2300, 340]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ replies: $('Parse Agent Response').first().json.replies, done: false }) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "respond-continue",
      "name": "Respond Continue",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2020, 800]
    }
  ],
  "connections": {
    "Task Agent Webhook": {
      "main": [
        [{ "node": "Fetch Active Tasks", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Active Tasks": {
      "main": [
        [{ "node": "Prepare AI Context", "type": "main", "index": 0 }]
      ]
    },
    "Prepare AI Context": {
      "main": [
        [{ "node": "Fetch Calendar Events", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Calendar Events": {
      "main": [
        [{ "node": "Enrich with Calendar", "type": "main", "index": 0 }]
      ]
    },
    "Enrich with Calendar": {
      "main": [
        [{ "node": "Task Agent AI", "type": "main", "index": 0 }]
      ]
    },
    "Task Agent AI": {
      "main": [
        [{ "node": "Parse Agent Response", "type": "main", "index": 0 }]
      ]
    },
    "Parse Agent Response": {
      "main": [
        [{ "node": "Route Action", "type": "main", "index": 0 }]
      ]
    },
    "Route Action": {
      "main": [
        [{ "node": "Split New Tasks", "type": "main", "index": 0 }],
        [{ "node": "Mark Complete", "type": "main", "index": 0 }],
        [{ "node": "Mark In Progress", "type": "main", "index": 0 }],
        [{ "node": "Soft Delete", "type": "main", "index": 0 }],
        [{ "node": "Snooze Task", "type": "main", "index": 0 }],
        [{ "node": "Respond Continue", "type": "main", "index": 0 }],
        [{ "node": "Respond Continue", "type": "main", "index": 0 }]
      ]
    },
    "Split New Tasks": {
      "main": [
        [{ "node": "Insert Task", "type": "main", "index": 0 }]
      ]
    },
    "Insert Task": {
      "main": [
        [{ "node": "Respond Action Done", "type": "main", "index": 0 }]
      ]
    },
    "Mark Complete": {
      "main": [
        [{ "node": "Respond Action Done", "type": "main", "index": 0 }]
      ]
    },
    "Mark In Progress": {
      "main": [
        [{ "node": "Respond Action Done", "type": "main", "index": 0 }]
      ]
    },
    "Soft Delete": {
      "main": [
        [{ "node": "Respond Action Done", "type": "main", "index": 0 }]
      ]
    },
    "Snooze Task": {
      "main": [
        [{ "node": "Respond Action Done", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [{ "name": "task-app" }]
}
